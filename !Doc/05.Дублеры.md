# Тестовые дублеры

## Виды тест-дублеров
Разные авторы используют разную терминологию. Будьте к этому готовы.
Мы берем за основу терминологию Роя Ошерова из книги "The art of unit testing"
- Тестовый дублер
  - Любой объект, который используется в тестах вместо реального объекта
- Stub
  - Заглушка
  - Управляемый дублер внешней зависимости
  - Используется в Arrange
- Mock
  - Дублер, который используется для регистрации внешних вызовов и проверки факта этого вызова или его отсутствия
  - Может быть строгим или нестрогим
  - Используется только в Assert 
- Spy
  - Дублер - декоратор над реальным объектом, который регистрирует вызовы
  - Используется только в Assert
- Fake
  - Объект, который может использоваться и как Stub и как Mock

Для сравнения терминология из книги Agile technical practices distilled:
- Dummy
  - Тупая заглушка, которая нужна чтобы просто код скомпилировался
  - Не содержит логики
  - Не используется в тесте
- Stub
  - Заглушка
  - Управляемый дублер внешней зависимости
  - Настраиваемое поведение
  - Используется в Arrange
- Fake
  - Stub, написанный вручную (Stub для бедных)
- Mock
  - Дублер - декоратор над реальным объектом, который регистрирует вызовы и проверяет ожидания этих вызовов
- Spy
  - Mock, написанный вручную

## Способы инъекции тест-дублеров
[Флип](https://disk.yandex.ru/d/150AIWfx3GU3BP/9_InjectionWays.jpg)
- Параметр метода
- Конструктор
- Публичный сеттер
- Extract and Override

## Полезные советы про тестовых дублеров
- Command-Query Separation
  - Команда изменяет состояние, но ничего не возвращает
    - Можно вернуть, это слабое нарушение
  - Запрос сообщает состояние, но не изменяет
- Используйте Stub для Запросов в Arrange
- Используйте Mock для проверки Команд в Assert
- Подменяйте только те классы, которыми вы владеете
  - Как подменять внешние библиотеки или зависимости? — Используйте классы-обертки и подменяйте их
- Проверяйте как можно меньше
  - Длинные проверки привязывают тесты к реализации → мешают рефакторингу
- Обходитесь без дублеров, если можете обойтись
  - Например для тестирования изолированных объектов
  - Используйте реальные доменные объекты, не бойтесь расширять SUT
- Не добавляйте поведение в дублеров
  - Дублирование логики
  - Риск начать тестировать логику дублера вместо продакшн кода
- Подменяйте только непосредственные зависимости
  - Сложная инициализация
  - Соблюдайте Закон Деметры
  - Class A -> Class B -> Class C
    - Не подменяйте Class С, вместо этого подмените Class B
- Если в тестах слишком много дублеров, меняйте дизайн

## Упражнение. Использование тестовых дублеров
- Задача: Написать тесты на выигрыш/проигрыш, которые зависят от
  значения кубика
  - Игрок сделал правильную ставку и выиграл
  - Игрок сделал неправильную ставку и проиграл
  - Мокируем кубик
- Обращаем внимание на
  - Наименование теста
  - Структуру теста (AAA)
  - Лаконичность и выразительность теста
  - Понятность тестовых данных
  - Уместное использование Stub

## Тесты на поведение и на состояние
[флип](https://photos.google.com/share/AF1QipM4blkk7aW1gCjKYsEJj9SngPxhdPRNcHanggVbgCugKyTkRUGb0GnsyxTu_I1Bqg/photo/AF1QipO6fp9-QqAsGgHbrXM05vn2VJjI7UGrM_iTbZAV?key=TUNISk5qSkVvaHdia1p0aXNSSHN0YTByMzl0cEp3)
- Value-based testing
- State-based testing
  - Integration testing

## Упражнение. Тесты на поведение / состояние
- Задача: Понять разницу между тестами на поведение и тестами на
  состояние
  - Поведение
    - Game.Play() бросает кубик
    - Game.Play() вызывает Player.Win() для всех игроков в игре, сделавших правильную ставку
    - Game.Play() вызывает Player.Lose() для всех игроков в игре, сделавших неправильную ставку
  - Состояние
    - После Game.Play() игрок, сделавший правильную ставку, выиграл 6 ставок
    - После Game.Play() все игроки, сделавшие правильные ставки, выиграли по 6 ставок каждый
    - После Game.Play() игрок, сделавший неправильную ставку, проиграл ставку
    - После Game.Play() все игроки, сделавшие неправильные ставки, проиграли свои ставки
- Дебриф: обращаем внимание на
  - Наименование теста
  - Структуру теста (AAA)
  - Отличие тестов на состояние и поведение
  - Лаконичность и выразительность теста
  - Тестовые данные важны для теста
  - Тестируется логика классов, а не тестовых дублеров
## Тестовые фреймворки
- Moq
- Mockito

## Упражнение. Тесты на поведение / состояние с использованием тестовых фреймворков
- Задача: Перепишите тесты на выигрыш/проигрыш с использованием тестовых фреймворков
  Правила игры поменялись. Кубик бросается несколько раз.
  Первый бросок показывает, сколько раз бросать кубик.
  Например, если в первый раз выпало 3, то нужно после этого бросить кубик 3 раза. Выигрывает игрок, который правильно угадал результат 3-го кубика.
- Дебриф: обращаем внимание на
  - Лаконичность и понятность теста
  - Оправданное использование тестовых дублеров

## Контрольные вопросы
- Что такое юнит тест?
- Что такое юнит?
- Структура юнит теста?
- Чем юнит тест отличается от интеграционного теста?
- На какие атрибуты качества влияет testability?
- Какие способы инъекции зависимости вы знаете? Когда какие применяются?
- Чем Stub отличается от Mock?
- Что такое тесты на состояние и поведение?
